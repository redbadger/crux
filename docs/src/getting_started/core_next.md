# Shared core (next)

Every Crux app has a library, written in Rust, which contains the _behavior_ of the app â€” the shared logic and
types. This library is often referred to as the "core" and is shared with each of the "shells" (which are written in
other languages such as Swift, Kotlin, and TypeScript). This page provides an overview of the core library and how
to set it up.

```admonish
The snippets on this page are taken from the
[`counter-next` example](https://github.com/redbadger/crux/tree/master/examples/counter-next),
which are a little bit more complex than the
[`simple_counter`](https://github.com/redbadger/crux/tree/master/examples/simple_counter)
example. When the latter has been updated, we'll switch to using that instead.
```

### Create the core crate

You can call the core whatever you like, but we have chosen the name `shared` here.
You can create the shared Rust library, like this:

```sh
cargo new --lib shared
```

### The workspace manifest

We'll be adding other folders into our monorepo, so we are choosing to use Cargo Workspaces.
Edit the workspace `/Cargo.toml` file, at the repository root, to add the new library to our workspace.
It should look something like this:

```toml
# /Cargo.toml
[workspace]
members = ["shared"]
resolver = "2"

[workspace.package]
authors = ["Red Badger Consulting Limited"]
edition = "2021"
repository = "https://github.com/redbadger/crux/"
license = "Apache-2.0"
keywords = ["crux", "crux_core", "cross-platform-ui", "ffi", "wasm"]
rust-version = "1.80"

[workspace.dependencies]
anyhow = "1.0.98"
crux_core = "0.14.0"
crux_http = "0.13.0"
serde = "1.0.219"
```

### The shared library manifest

The library's manifest, at `/shared/Cargo.toml`, should look something like the
following, but there are a few things to note:

- the `crate-type`
  - `lib` is the default rust library when linking into a rust binary, e.g. in
    a `web-leptos`, or `cli`, variant
  - `staticlib` is a static library (`libshared.a`) for including in a Swift
    iOS app variant
  - `cdylib` is a C-ABI dynamic library (`libshared.so`) for use with JNA when
    included in a Kotlin Android app variant
- we also declare a binary called `crux_cli` that we will use to generate foreign
  types and bindings. We include it in our shared library by adding a file at
  `src/bin/crux_cli.rs` (see below) that allows us to build the tool at the
  right version.
- we add a feature called `cli` that allows us to build the `crux_cli` binary with
  the `cli` feature from `crux_core` without having to include that code in our
  shared library.
- to support the bindings, we add either 'uniffi' or 'wasm-bindgen' depending
  on the platform that we are building for. The version of `uniffi` is important
  because it must match the version of `uniffi-bindgen` used to generate the
  bindings. If the versions do not match, we will get a helpful compile error.

```toml
# /shared/Cargo.toml
{{#include ../../../examples/counter-next/shared/Cargo.toml}}
```

Ok, let's add the `crux_cli` binary to our shared library by adding a file at
`src/bin/crux_cli.rs` that allows us to build the tool at the
right version:

```rust,no_run,noplayground
// /shared/src/bin/crux_cli.rs
{{#include ../../../examples/counter-next/shared/src/bin/crux_cli.rs}}
```

There's one last thing we need to do and that is to configure the bindings. We need to add a
file at `/shared/uniffi.toml`:

```toml
# /shared/uniffi.toml
{{#include ../../../examples/counter-next/shared/uniffi.toml}}
```

### The app

Now we are in a position to create a basic app in `/shared/src/app.rs`. This is
from the
[`counter-next` example](https://github.com/redbadger/crux/blob/master/examples/counter-next/shared/src/counter.rs)
(which also has tests, although we're not showing them here).

```rust,no_run,noplayground
// /shared/src/app.rs
{{#include ../../../examples/counter-next/shared/src/app.rs:app}}
```

```admonish note title="Note the #[effect] macro"
The [`#[effect]`](https://docs.rs/crux_macros/latest/crux_macros/macro.effect.html) macro can be used to annotate an enum to represent our effects. The enum has a variant for each effect, which carries the [`Operation`](https://docs.rs/crux_core/latest/crux_core/capability/trait.Operation.html) type.

The real effect type generated by the macro is a little more complicated, with some plumbing to support the foreign function interface into Swift, Kotlin and other languages. You can read more about the effect system in the [Managed Effects](../guide/effects.md) chapter of the guide.
```

```admonish note title="Note the #[bridge] macro"
The [`#[bridge]`](https://docs.rs/crux_macros/latest/crux_macros/macro.bridge.html) macro generates the scaffolding
for the bridge between the Rust and Swift/Kotlin/TypeScript codebases. It creates the necessary glue code (with the
help of `uniffi` or `wasm-bindgen`) to allow the "core" and the "shell" to communicate with each other.

If you have only Rust shells, you can just `[#derive(Default)]`, otherwise place this macro on the struct that
implements the `App` trait (and which represents the root of your app hierarchy).
```

```admonish warning title="The Capabilities associated type"
The `Capabilities` associated type in the code above is an artifact of a migration of the effect API from
previous versions of Crux. You can use the unit type `()` and everything will work fine. We will
eventually remove this type and the last argument to the `update` function.

If you've got an existing app or you're simply curious about what this looked like before, you can read about it
at the end of the [Managed Effects](../guide/effects.md) chapter of the guide.
```

Make sure everything builds OK

```sh
cargo build
```
