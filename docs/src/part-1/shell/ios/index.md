# iOS â€” Swift and SwiftUI

In this section, we'll set up Xcode to build and run the simple counter app we built so far.

```admonish tip
We think that using [XcodeGen](https://github.com/yonaskolb/XcodeGen) may be the simplest way to create an Xcode project to build and run a simple iOS app that calls into a shared core.

If you'd rather set up Xcode manually, you can do that, but most of this section will still apply. You just need to
add the Swift package dependencies into your project by hand.
```

When we use Crux to build iOS apps, the Core API bindings are generated in Swift
(with C headers) using Mozilla's [UniFFI](https://mozilla.github.io/uniffi-rs/).

The shared core, which we built in previous chapters, is compiled to a static
library and linked into the iOS binary.

The shared types are generated by Crux as a Swift package, which we can add to
our iOS project as a dependency. The Swift code to serialize and deserialize
these types across the boundary is also generated by Crux as Swift packages.

![build flow](./flow.svg)

## Compile our Rust shared library

When we build our iOS app, we also want to build the Rust core as a static
library so that it can be linked into the binary that we're going to ship.

Other than Xcode and the Apple developer tools, we will use
[`cargo-swift`](https://crates.io/crates/cargo-swift) to generate a
Swift package for our shared library, which we can add in Xcode.

To match our current version of UniFFI, we need to install version 0.9 of `cargo-swift`. You can install it with

```bash
cargo install cargo-swift --version '=0.9'
```

To run the various steps, we'll also use the [Just]() task runner.

```bash
cargo install just
```

Let's write the Justfile and we can look at what happens:

```makefile
# /iOS/Justfile

{{#include ../../../../../examples/simple_counter/iOS/Justfile}}
```

We have quite a few tasks. The main one is `dev` which we'll use shortly. It
runs the `build` task and opens Xcode in the current directory.

`build` in turn runs `typegen`, `package` and `generate-project`. `typegen`
will use the codegen CLI we [prepared earlier](../../shell.md), and
`package` will use `cargo swift` to create a `Shared` package with our app binary and the
bindgen code. That package will be our Swift interface to the core.

Finally `generate-project` will run `xcodegen` to give us an Xcode
project file. They are famously fragile files and difficult to version control,
so generating it from a less arcane source of truth seems like a good idea
(yes, even if that source of truth is YAML).

Here's the project file:

```yaml
# /iOS/project.yml
{{#include ../../../../../examples/simple_counter/iOS/project.yml}}
```

Nothing too special, other than linking a couple packages and using them
as dependencies.

With that, you can run

```bash
just dev
```

Simple - just dev! So what exactly happened?

The core built, including the FFI and the extra CLI binary, which was then called
to generate Swift code, and that was then packaged as a Swift package. You can
look at the `generated` directory, and you'll see two Swift packages - `Shared` and `App`,
just like we asked in `project.yml`. The `Shared` package has our app as a static lib and all the
generated FFI code for our FFI bindings, and the `App` package has the key types we will need.

No need to spend much time in here, but this is all the low-level glue code sorted out.
Now we need to actually build some UI and we can run our app.

## Building the UI

To add some UI, we need to do three things: wrap the core with a simple Swift
interface, build a basic View to give us something to put on screen, and use that
view as our main app view.

### Wrap the core

The generated code still works with byte buffers, so lets give ourselves a nicer
interface for it:

```swift
// iOS/SimpleCounter/core.swift
{{#include ../../../../../examples/simple_counter/iOS/SimpleCounter/core.swift}}
```

This is mostly just serialization code. But the `processEffect` method is interesting.
That is where effect execution goes. At the moment the switch statement has a single
lonely case updating the view model whenever the `.render` variant is requested,
but you can add more in here later, as you expand your `Effect` type.

### Build a basic view

Xcode should've generated a ContentView file for you in `iOS/SimpleCounter/ContentView.swift`.
Change it to look like this:

```swift
{{#include ../../../../../examples/simple_counter/iOS/SimpleCounter/ContentView.swift}}
```

And finally, make sure `iOS/SimpleCounter/SimpleCounterApp.swift` looks like this to use
the `ContentView`:

```swift
{{#include ../../../../../examples/simple_counter/iOS/SimpleCounter/SimpleCounterApp.swift}}
```

The one interesting part of this is the `@ObservedObject var core: Core`. Since the `Core` is
an `ObservableObject`, we can subscribe to it to refresh our view. And we've marked the `view`
property as `@Published`, so whenever we set it, the View will draw.

The view then simply shows the `core.view.count` in a `Text` and whenever we press a button, we directly
call `core.update()` with the appropriate action.

```admonish success
You should then be able to run the app in the simulator or on an iPhone, and it should look like this:

<p align="center"><img alt="simple counter app" src="./simple_counter.webp"  width="300"></p>
```
